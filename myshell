#include "parser.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/types.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <unistd.h>

tline *line;

void RevisarErrorFork(int pid) {
    if (pid < 0) {
        fprintf(stderr, "Error, fallo al crear el hijo\n");
        exit(1);
    }
}

void RevisarErrorMandato(int contador) {
    if (line->commands[contador].filename == NULL) {
        fprintf(stderr, "Error, no se encuentra el mandato %s\n", line->commands[contador].argv[0]);
        exit(2);
    }
}

void RevisarErrorAperturaFichero(int fileDescriptor) {
    if (fileDescriptor < 0) {
        fprintf(stderr, "error al abrir el fichero %s\n", line->redirect_input);
        exit(3);
    }
}

void RevisarErrorCreacionFicheroStdout(int fileDescriptor) {
    if (fileDescriptor < 0) {
        fprintf(stderr, "error al crear el fichero %s\n", line->redirect_output);
        exit(4);
    }
}

void RevisarErrorCreacionFicheroStderr(int fileDescriptor) {
    if (fileDescriptor < 0) {
        fprintf(stderr, "error al crear el fichero%s\n", line->redirect_error);
        exit(5);
    }
}

void RevisarErrorDup2(int errorCode) {
    if (errorCode < 0) {
        fprintf(stderr, "Se produjo un erro en las redirecciones(dup2)");
        exit(6);
    }
}


void RevisarErrorCd(const char *dir, int errorInt) {
    if (errorInt < 0) {
        fprintf(stderr, "Error, no se pudo cambiar al directorio: %s\n", dir);
    }
}

void ExecuteCD(void) {
    char *dir;
    int errorInt;

    if (line->commands[0].argv[1] == NULL) {
        dir = getenv("HOME");

    } else {
        dir = line->commands[0].argv[1];
    }

    errorInt = chdir(dir);
    RevisarErrorCd(dir, errorInt);
}


void closePipes(int **arrayPipes) {
    int contador;
    for (contador = 0; contador < line->ncommands - 1; contador++) {
        close(arrayPipes[contador][0]);
        close(arrayPipes[contador][1]);
    }
    free(arrayPipes);
}


int **CrearArrayPipes() {
    int **arrayPipes;
    int contador;
    if (line->ncommands > 1) {
        return NULL;
    } else {
        arrayPipes = (int **) malloc(sizeof(int *) * line->ncommands - 1);
        for (contador = 0; contador < line->ncommands - 1; contador++) {
            arrayPipes[contador] = (int *) malloc(sizeof(int) * 2);
            pipe(arrayPipes[contador]);
        }
        return arrayPipes;
    }
}


void GestionarRedireccionesSalidaFichero(int contador) {
    int error = 0;
    int fileDescriptor;
    if (contador == line->ncommands - 1) {
        if (line->redirect_output != NULL) {
            fileDescriptor = create(line->redirect_output, 0644);
            RevisarErrorCreacionFicheroStdout(fileDescriptor);

            error = dup2(fileDescriptor, 1);
            RevisarErrorDup2(errorCode);
            close(fileDescriptor);
        }
        if (line->redirect_error != NULL) {
            fileDescriptor = create(line->redirect_error, 0644);
            RevisarErrorCreacionFicheroStderr(fileDescriptor);

            error = dup2(fileDescriptor, 2);
            RevisarErrorDup2(errorCode);
            close(fileDescriptor);
        }
    }
}

void GestionarPipesIO(int **arrayPipes, int contador) {
    int error = 0;
    if (line->ncommands > 1) {
        if (contador == 0) {
            error = dup2(arrayPipes[0][1], 1);
        } else if (contador == (line->ncommands - 1)) {
            error = dup2(arrayPipes[contador - 1][0], 0);
        } else {
            error = dup2(arrayPipes[contador][1], 1);
            error += dup2(arrayPipes[contador - 1][0], 0);
        }
        RevisarErrorDup2(errorCode);
        closePipes(arrayPipes);
    }
}

void GestionarRedireccionesEntradaFichero(int contador) {
    int error=0;
    int fileDescriptor;
    if ((contador == 0) && (line->redirect_input != NULL)) {
        fileDescriptor = open(line->redirect_input, O_RDONLY);
        RevisarErrorAperturaFichero(fileDescriptor);

        error = dup2(fileDescriptor, 0);
        RevisarErrorDup2(errorCode);
        close(fileDescriptor);
    }
}

void AjustarProcesoHijo(int contador) {
    if (line->background == 1) {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
    }
    RevisarErrorMandato(contador);
    GestionarRedireccionesEntradaFichero(contador);
}

void EsperarHijos(int *arrayPIDs) {
    int contador;
    for (contador = 0; contador < line->ncommands; contador++) {
        waitpid(arrayPIDs[contador], NULL, 0);
    }
}

void Ejecutar(void) {
    int **arrayPipes;
    int *arrayPIDs;
    int fileDescriptor;
    int contador;
    pid_t pid;
    int error = 0;

    arrayPIDs = malloc(sizeof(pid_t) * line->ncommands);

    arrayPipes = CrearArrayPipes();

    for (contador = 0; contador < line->ncommands; contador++) {
        pid = fork();
        RevisarErrorFork(pid);
        arrayPIDs[contador] = pid;
        if (pid == 0) {
            AjustarProcesoHijo(contador);
        }

        GestionarRedireccionesSalidaFichero(contador);

        GestionarPipesIO(arrayPipes, contador);

        execvp(line->commands[contador].filename, line->commands[contador].argv);
        exit(1);//todo ?????
    }
    if (line->ncommands > 1) {
        closePipes(arrayPipes);
    }
    if (line->background) {
        for (contador = 0; contador < line->ncommands; contador++) {
            printf("[%d]\n", arrayPIDs[contador]);//todo ????
        }
    } else {
        EsperarHijos(arrayPIDs);
    }
    free(arrayPIDs);
}

void manejador(int sig) {
    waitpid(WAIT_ANY, NULL, WNOHANG);
}

int main(void) {
    char buffer[1024];

    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGCHLD, manejador);
    while (fgets(buffer, 1024, stdin)) {
        printf("\nmsh>");
        line = tokenize(buffer);
        if (line != NULL) {
            if (strcmp(line->commands[0].argv[0], "cd") == 0) {
                ExecuteCD();
            } else {
                Ejecutar();
            }
        }
    }
    return 0;
}
