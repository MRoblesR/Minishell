#include "parser.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/types.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <unistd.h>

tline *line;

int RevisarErrores(int tipo, int contador, int errorCode, int fileDescriptor, int pid) {
    switch (tipo) {
        case 1:
            if (pid < 0) {
                fprintf(stderr, "Error, fallo al crear el hijo\n");
                exit(1);
            }
            break;
        case 2:
            if (line->commands[contador].filename == NULL) {
                fprintf(stderr, "Error, no se encuentra el mandato %s\n", line->commands[contador].argv[0]);
                exit(2);
            }
            break;
        case 3:
            if (fileDescriptor < 0) {
                fprintf(stderr, "error al abrir el fichero %s\n", line->redirect_input);
                exit(3);
            }
            break;
        case 4:
            if (fileDescriptor < 0) {
                fprintf(stderr, "error al crear el fichero %s\n", line->redirect_output);
                exit(4);
            }
            break;
        case 5:
            if (fileDescriptor < 0) {
                fprintf(stderr, "error al crear el fichero%s\n", line->redirect_error);
                exit(5);
            }
            break;
        case 6:
            if (errorCode < 0) {
                fprintf(stderr, "Se produjo un erro en las redirecciones(dup2)");
                exit(6);
            }
            break;

        default:
            fprintf(stderr, "error, este error no estÃ¡ definido\n");
            exit(100);
    }
    return 0;
}

void ExecuteCD(void) {
    char *dir;
    int errorInt;

    if (line->commands[0].argv[1] == NULL) {
        dir = getenv("HOME");

    } else {
        dir = line->commands[0].argv[1];
    }

    errorInt = chdir(dir);
    if (errorInt < 0) {
        fprintf(stderr, "Error, no se pudo cambiar al directorio: %s\n", dir);
    }
}


void closePipes(int **arrayPipes) {
    int contador;
    for (contador = 0; contador < line->ncommands - 1; contador++) {
        close(arrayPipes[contador][0]);
        close(arrayPipes[contador][1]);
    }
    free(arrayPipes);
}


int **CrearArrayPipes() {
    int **arrayPipes;
    int contador;
    if (line->ncommands > 1) {
        return NULL;
    } else {
        arrayPipes = (int **)malloc(sizeof(int *) * line->ncommands - 1);
        for (contador = 0; contador < line->ncommands - 1; contador++) {
            arrayPipes[contador] = (int *)malloc(sizeof(int) * 2);
            pipe(arrayPipes[contador]);
        }
        return arrayPipes;
    }
}


void GestionarRedireccionesSalidaFichero(int fileDescriptor, int contador, pid_t &pid) {
    int error = 0;
    if (contador == line->ncommands - 1) {
        if (line->redirect_output != NULL) {
            fileDescriptor = create(line->redirect_output, 0644);
            RevisarErrores(4, contador, 0, fileDescriptor, pid);

            error = dup2(fileDescriptor, 1);
            RevisarErrores(6, 0, error, NULL, 0);
            close(fileDescriptor);
        }
        if (line->redirect_error != NULL) {
            fileDescriptor = create(line->redirect_error, 0644);
            RevisarErrores(5, contador, 0, fileDescriptor, pid);

            error = dup2(fileDescriptor, 2);
            RevisarErrores(6, 0, error, NULL, 0);
            close(fileDescriptor);
        }
    }
}

void GestionarPipesIO(int **arrayPipes, int contador) {
    int error = 0;
    if (line->ncommands > 1) {
        if (contador == 0) {
            error = dup2(arrayPipes[0][1], 1);
        } else if (contador == (line->ncommands - 1)) {
            error = dup2(arrayPipes[contador - 1][0], 0);
        } else {
            error = dup2(arrayPipes[contador][1], 1);
            error += dup2(arrayPipes[contador - 1][0], 0);
        }
        RevisarErrores(6, 0, error, NULL, 0);
        closePipes(arrayPipes);
    }
}

void GestionarRedireccionesEntradaFichero(int fileDescriptor, int contador, const pid_t &pid, int error) {
    if ((contador == 0) && (line->redirect_input != NULL)) {
        fileDescriptor = open(line->redirect_input, O_RDONLY);
        RevisarErrores(3, contador, 0, fileDescriptor, pid);

        error = dup2(fileDescriptor, 0);
        RevisarErrores(6, 0, error, NULL, 0);
        close(fileDescriptor);
    }
}

void AjustarProcesoHijo(int fileDescriptor, int contador, const pid_t &pid, int error) {
    if (line->background == 1) {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
    }
    RevisarErrores(2, contador, 0, 0, pid);
    GestionarRedireccionesEntradaFichero(fileDescriptor, contador, pid, error);
}

void EsperarHijos(const int *arrayPIDs) {
    int contador;
    for (contador = 0; contador < line->ncommands; contador++) {
        waitpid(arrayPIDs[contador], NULL, 0);
    }
}

void Ejecutar(void) {
    int **arrayPipes;
    int *arrayPIDs;
    int fileDescriptor;
    int contador;
    pid_t pid;
    int error = 0;

    arrayPIDs = malloc(sizeof(pid_t) * line->ncommands);

    arrayPipes = CrearArrayPipes();

    for (contador = 0; contador < line->ncommands; contador++) {
        pid = fork();
        RevisarErrores(1, contador, 0, 0, pid);
        arrayPIDs[contador] = pid;
        if (pid == 0) {
            AjustarProcesoHijo(fileDescriptor, contador, pid, error);
        }

        GestionarRedireccionesSalidaFichero(fileDescriptor, contador, pid);

        GestionarPipesIO(arrayPipes, contador);


        execvp(line->commands[contador].filename, line->commands[contador].argv);
        exit(1);//todo ?????
    }
    if (line->ncommands > 1) {
        closePipes(arrayPipes);
    }
    if (line->background) {
        for (contador = 0; contador < line->ncommands; contador++) {
            printf("[%d]\n", arrayPIDs[contador]);//todo ????
        }
    } else {
        EsperarHijos(arrayPIDs);
    }
    free(arrayPIDs);
}

void manejador(int sig) {
    waitpid(WAIT_ANY, NULL, WNOHANG);
}

int main(void) {
    char buffer[1024];

    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGCHLD, manejador);
    while (fgets(buffer, 1024, stdin)) {
        printf("\nmsh>");
        line = tokenize(buffer);
        if (line != NULL) {
            if (strcmp(line->commands[0].argv[0], "cd") == 0) {
                ExecuteCD();
            } else {
                Ejecutar();
            }
        }
    }
    return 0;
}
