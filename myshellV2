#include "parser.h"
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/types.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <unistd.h>

tline *line;

void RevisarErrorFork(int pid){
    if (pid < 0){
        fprintf(stderr, "Error, fallo al crear el hijo\n");
        exit(1);
    }
}

void RevisarErrorMandato(int contador){
    if (line->commands[contador].filename == NULL){
        fprintf(stderr, "%s: No se encuentra el mandato\n", line->commands[contador].argv[0]);
        exit(2);
    }
}

void RevisarErrorAperturaFichero(int fileDescriptor){
    if (fileDescriptor < 0){
        fprintf(stderr, "error al abrir el fichero %s\n", line->redirect_input);
        exit(3);
    }
}

void RevisarErrorCreacionFicheroStdout(int fileDescriptor){
    if (fileDescriptor < 0){
        fprintf(stderr, "error al crear el fichero %s\n", line->redirect_output);
        exit(4);
    }
}

void RevisarErrorCreacionFicheroStderr(int fileDescriptor){
    if (fileDescriptor < 0){
        fprintf(stderr, "error al crear el fichero%s\n", line->redirect_error);
        exit(5);
    }
}

void RevisarErrorDup2(int errorCode){
    if (errorCode < 0){
        fprintf(stderr, "Se produjo un error en las redirecciones(dup2)");
        exit(6);
    }
}


void RevisarErrorCd(const char *dir, int errorInt){
    if (errorInt < 0){
        fprintf(stderr, "Error, no se pudo cambiar al directorio: %s\n", dir);
    }
}

void ExecuteCD(void){
    char *dir;
    int errorInt;

    if (line->commands[0].argv[1] == NULL){
        dir = getenv("HOME");

    }else{
        dir = line->commands[0].argv[1];
    }

    errorInt = chdir(dir);
    RevisarErrorCd(dir, errorInt);
}


void closePipes(int **arrayPipes){
    int contador;
    for (contador = 0; contador < line->ncommands - 1; contador++){
        close(arrayPipes[contador][0]);
        close(arrayPipes[contador][1]);
    }
    free(arrayPipes);
}


int **CrearArrayPipes(){
    int **arrayPipes;
    int contador;
    if (line->ncommands > 1){
        return NULL;
    }else{
        arrayPipes = (int **) malloc(sizeof(int *) * line->ncommands - 1);
        for (contador = 0; contador < line->ncommands - 1; contador++){
            arrayPipes[contador] = (int *) malloc(sizeof(int) * 2);
            pipe(arrayPipes[contador]);
        }
        return arrayPipes;
    }
}


void GestionarRedireccionesSalidaFichero(int contador){
    int errorCode = 0;
    int fileDescriptor;
    if (contador == line->ncommands - 1){
        if (line->redirect_output != NULL){
            fileDescriptor = creat(line->redirect_output, 0644);
            RevisarErrorCreacionFicheroStdout(fileDescriptor);

            errorCode = dup2(fileDescriptor, 1);
            RevisarErrorDup2(errorCode);
            close(fileDescriptor);
        }
    }
}

void GestionarRedireccionesErrorFichero(int contador){
    int errorCode = 0;
    int fileDescriptor;
    if (contador == line->ncommands - 1){
        if (line->redirect_error != NULL){
            fileDescriptor = creat(line->redirect_error, 0644);
            RevisarErrorCreacionFicheroStderr(fileDescriptor);

            errorCode = dup2(fileDescriptor, 2);
            RevisarErrorDup2(errorCode);
            close(fileDescriptor);
        }
    }
}

void GestionarPipesIO(int **arrayPipes, int contador){
    int errorCode = 0;
    if (line->ncommands > 1){
        if (contador == 0){
            errorCode = dup2(arrayPipes[0][1], 1);
        } else if (contador == (line->ncommands - 1)){
            errorCode = dup2(arrayPipes[contador - 1][0], 0);
        } else{
            errorCode = dup2(arrayPipes[contador][1], 1);
            errorCode += dup2(arrayPipes[contador - 1][0], 0);
        }
        RevisarErrorDup2(errorCode);
        closePipes(arrayPipes);
    }
}

void GestionarRedireccionesEntradaFichero(int contador){
    int errorCode = 0;
    int fileDescriptor;
    if ((contador == 0) && (line->redirect_input != NULL)){
        fileDescriptor = open(line->redirect_input, O_RDONLY);
        RevisarErrorAperturaFichero(fileDescriptor);

        errorCode = dup2(fileDescriptor, 0);
        RevisarErrorDup2(errorCode);
        close(fileDescriptor);
    }
}

void AjustarProcesoHijo(int contador){
    if (line->background == 0){
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
    }
    RevisarErrorMandato(contador);
}

void EsperarHijos(int *arrayPIDs){
    int contador;
    for (contador = 0; contador < line->ncommands; contador++){
        waitpid(arrayPIDs[contador], NULL, 0);
    }
}

void Execute(void){
    int **arrayPipes;
    int *arrayPIDs;
    int contador;
    pid_t pid;

    arrayPIDs = malloc(sizeof(pid_t) * line->ncommands);

    arrayPipes = CrearArrayPipes();

    for (contador = 0; contador < line->ncommands; contador++){
        pid = fork();
        RevisarErrorFork(pid);
        arrayPIDs[contador] = pid;
        if (pid == 0){
            AjustarProcesoHijo(contador);
            GestionarRedireccionesEntradaFichero(contador);
            GestionarRedireccionesSalidaFichero(contador);
            GestionarRedireccionesErrorFichero(contador);
            GestionarPipesIO(arrayPipes, contador);
            execvp(line->commands[contador].filename, line->commands[contador].argv);
            exit(1);
    	}
    }
    if (line->ncommands > 1){
        closePipes(arrayPipes);
    }
    if (line->background == 1){
        for (contador = 0; contador < line->ncommands; contador++){
            printf("[%d]\n", arrayPIDs[contador]);//todo ????
        }
    } else{
        EsperarHijos(arrayPIDs);
    }
    free(arrayPIDs);
}

void manejador(int sig){
    waitpid(WAIT_ANY, NULL, WNOHANG);
}

int main(void){
    char buffer[1024];
    printf("msh> ");

    signal(SIGINT, SIG_IGN);
    signal(SIGQUIT, SIG_IGN);
    signal(SIGCHLD, manejador);
    while (scanf("%s",buffer)){
        line = tokenize(buffer);
        if (strcmp(line->commands[0].argv[0], "cd") == 0){
            ExecuteCD();
        }else{
            Execute();
        }
        printf("\nmsh> ");
    }
    return 0;
}
